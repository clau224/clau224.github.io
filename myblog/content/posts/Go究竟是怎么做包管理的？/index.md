
+++

date = '2025-09-02T19:38:52+08:00'
draft = false
title = 'Go究竟是怎么做包管理的'
summary = '在从Java转入Go后，让我感到非常爽的一点在于Go的依赖包管理。这让我对Go Module感到好奇...'


+++


![](cover.jpg)


## 1. 为什么我想聊聊这个？
在从Java转入Go后，让我感到非常爽的一点在于go的依赖包管理。

go.mod对依赖的声明很简单啊有没有，依赖包是属于哪个仓库，一目了然！再也不用去找Maven坐标了，也没有复杂的生命周期、打包类型声明等等。

而且命令也很简洁实用，当我执行go mod tidy，它在自动帮我下载依赖包的同时，竟然还能帮我清理掉没有被引用的依赖包，用惯了maven的我感到有点爽哈哈哈；另外，go mod why 还能看到某个依赖包被哪些包引用了，这不仅让我想起maven中查看dependency tree时被支配的恐惧。

那么，我挺好奇Go是如何做依赖包管理的。比如在执行go mod的相关命令时，底层发生了什么；以及部分Maven让人头疼的地方，Go Module是怎么解决的。

OK，让我们探究一下Go Module吧！


## 2. 当我们执行go mod tidy，底层发生了什么事？

**step-1：依赖解析与构建依赖图**

go mod tidy 的第一步是扫描项目中的所有 Go 文件，解析其中的 import 声明，构建完整的依赖关系图。这一过程的具体步骤包括：
1. 遍历文件系统：从 go.mod 所在目录开始递归遍历，识别所有包含 Go 代码的目录，并提取每个包的导入路径。这一步的核心目的是收集项目中所有实际使用的依赖包路径。
2. 构建依赖树：根据导入路径，递归解析每个依赖模块的 go.mod 文件，构建包含直接和间接依赖的完整依赖图。例如，若我们的项目A直接导入了模块B，而B又导入了模块C，则项目A的依赖图包含B和C。
3. 识别缺失依赖：对比解析出的导入路径与go.mod中的声明，标记未被声明的依赖项。例如，若代码中导入了github.com/foo/bar/v2，但 go.mod 中未包含该模块，则视为缺失依赖。

**step-2：更新go.mod文件**

在生成依赖图后，go mod tidy会调整go.mod文件。
1. 添加缺失依赖：将代码中实际使用但未声明的模块添加到 go.mod，并记录其版本。例如，若代码导入了 github.com/google/uuid v1.3.0，但 go.mod 中未包含，则自动添加该条目。
2. 移除未使用依赖：删除 go.mod 中未被代码直接或间接引用的模块。例如，若某个模块的导入路径被从代码中删除，go mod tidy 会将其从 go.mod 中移除。
3. 更新间接依赖版本： 这一步比较复杂，我会在下面单独分析一下。它能够解决Maven中的“版本地狱”问题，但我个人认为会引入一些不稳定性。

**step-3：下载依赖包**

会根据地址进行下载，这个环节不赘述了，但是下载过程是进行了优化：
1. 并行下载：默认启用高并发下载依赖，加速处理过程。可通过 GOMAXPROCS 环境变量调整并发数。
2. 本地缓存复用：从 $GOPATH/pkg/mod 缓存中读取已下载的模块，避免重复下载。

**step-4：维护go.sum文件**

我之前每次升级依赖版本并执行go mod tidy后，都会自动更新go.sum，当时还比较奇怪他的作用机制。这次正好也梳理到了，大概有两步操作：
1. 校验和验证：下载依赖模块后，计算其哈希值（默认使用 SHA-256），并与 sum.golang.org（由 GOSUMDB 环境变量配置，也很眼熟，入职配置之一）中的记录比对。若不一致，则报错并拒绝更新 go.sum。
2. 更新校验和：将新下载模块的校验和写入 go.sum，并删除不再使用的依赖的校验和条目。例如，移除未使用依赖后，对应的 go.sum 条目也会被清理。

**step-5：处理特殊指令**

我在项目中，发现有类似 replace github.com/xxx/yyy => ./local/xxx/yyy，这些指令都需要处理。
1. replace指令：替换依赖的实际路径或版本。例如，上面的例子，会将所有对 github.com/xxx/yyy 的依赖指向本地路径。replace仅在当前模块为主模块时生效。
2. exclude指令：排除特定版本的依赖。例如，exclude github.com/xxx/yyy v1.0.0 会禁止使用该版本，强制选择其他兼容版本。

以上，就完成了go mod tidy的全流程执行。


## 3. Go Modele怎么解决“版本地狱”问题
在Java中，经常会遇到版本冲突问题，比如多个Maven依赖同时依赖了一个更底层的jar包，但是呢，对jar包的版本存在冲突，需要手动去解，每次mvn dependency tree，都感到头疼。而Go Module则使用最小版本选择（MVS）算法，自动确定依赖版本，。

这一过程大概分为两步，先是分析依赖关系，收集版本需求，选择最大版本：然后迭代稳定化，可能从最大版本往下进行尝试。

说概念比较晦涩难懂，我举一个例子具体说说。

我们的项目叫MyApp，他直接依赖两个模块，分别是模块A和模块B。
- MyApp对A的版本要求是>=1.0.0
- MyApp对B的版本要求是>=1.0.0

同时，A和B都依赖模块C，且：
- A对C的版本要求是>=1.3.0, 
- B对C的版本要求是>=2.0.0

那么，在第一步收集版本需求后，会选择1.0.0版本的A、1.0.0版本的B和2.0.0版本的C，这样能同时满足MyApp对A、B和C的版本要求。

在第二步中，可能发现了一个问题：

检查模块A，发现它依赖了一个在C的2.0.0版本中已经废弃的接口（这个接口在1.3.0正常使用，但是从C的2.0.0版本开始进行了废弃）。这时候，如果我们把C的版本降级到2.0.0前一个版本（比如1.9.0），那么会发现不满足B对C的版本要求了。

那么，怎么办呢？这时候需要对A的版本进行升级，以此来提升A对C的版本依赖。比如这时候发现A的1.1.0对C的版本提升到了2.0.0，能正常使用C的接口了。

接下来，再次验证A、B、C的版本是否符合MyApp的版本要求。看来是符合了，那么这时候，A、B、C的版本就被确定下来了。A事1.1.0，B是1.0.0，C是2.1.0。

上面的过程可能会反复执行多次，知道寻找到各方都满意的平衡点。


## 4. Go Vendor是怎么回事？
在项目中，我还发现了一个关于Go Module的特殊用法。就是可以通过go mod vendor指令，将依赖包源码放到项目的vendor/目录下面。

它能解决什么场景呢？比如我在测试的时候，调用的某个依赖包在dev环境不生效，也就是离线构建场景。那么我需要更改里面的实现。这时，可以在测试分支上，将依赖下载到本地，然后更改依赖包中的实现，在启动时，增加`-mod=vendor`参数即可。

除此之外，我认为vendor还适用于另外以下场景：
1. 统一依赖配置：有时要确保团队所有成员使用完全相同的依赖代码（避免因外部依赖更新导致不一致）。
2. 使用失效版本：即使外部仓库删除了某个版本标签，vendor中保存的代码仍可保证项目可构建。


<div style="text-align: right; margin-top: 2em; font-style: italic; color: #666;">
  2025年09月03日 22点55分<br>
  于 大连·柏悦国际
</div>